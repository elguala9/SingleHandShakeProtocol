"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "NpmScriptRunner", {
    enumerable: true,
    get: function() {
        return NpmScriptRunner;
    }
});
const _path = require("path");
const _promises = require("fs/promises");
const _child_process = require("child_process");
const _os = /*#__PURE__*/ _interop_require_default(require("os"));
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
class NpmScriptRunner {
    getNpmArgs(task, taskArgs) {
        const extraArgs = taskArgs.length > 0 ? [
            "--",
            ...taskArgs
        ] : [];
        return [
            "run",
            task,
            ...extraArgs
        ];
    }
    async hasNpmScript(target) {
        const task = target.options?.script ?? target.task;
        const packageJsonPath = (0, _path.join)(target.cwd, "package.json");
        const packageJson = JSON.parse(await (0, _promises.readFile)(packageJsonPath, "utf8"));
        return !!packageJson.scripts?.[task];
    }
    async shouldRun(target) {
        // By convention, do not run anything if there is no script for this task defined in package.json (counts as "success")
        const hasNpmScript = await this.hasNpmScript(target);
        return hasNpmScript && (target.shouldRun ?? true);
    }
    async run(runOptions) {
        const { target, weight, abortSignal } = runOptions;
        const { nodeOptions, npmCmd, taskArgs } = this.options;
        const task = target.options?.script ?? target.task;
        let childProcess;
        /**
     * Handling abort signal from the abort controller. Gracefully kills the process,
     * will be handled by exit handler separately to resolve the promise.
     */ if (abortSignal) {
            if (abortSignal.aborted) {
                return {
                    exitCode: 1
                };
            }
            const abortSignalHandler = ()=>{
                abortSignal.removeEventListener("abort", abortSignalHandler);
                if (childProcess && !childProcess.killed) {
                    const pid = childProcess.pid;
                    process.stdout.write(`Abort signal detected, attempting to killing process id ${pid}\n`);
                    childProcess.kill("SIGTERM");
                    // wait for "gracefulKillTimeout" to make sure everything is terminated via SIGKILL
                    const t = setTimeout(()=>{
                        if (childProcess && !childProcess.killed) {
                            childProcess.kill("SIGKILL");
                        }
                    }, NpmScriptRunner.gracefulKillTimeout);
                    // Remember that even this timeout needs to be unref'ed, otherwise the process will hang due to this timeout
                    if (t.unref) {
                        t.unref();
                    }
                }
            };
            abortSignal.addEventListener("abort", abortSignalHandler);
        }
        /**
     * Actually spawn the npm client to run the task
     */ const args = [
            ...taskArgs,
            ...target.options?.taskArgs ?? []
        ];
        const npmRunArgs = this.getNpmArgs(task, args);
        const npmRunNodeOptions = [
            nodeOptions,
            target.options?.nodeOptions
        ].filter((str)=>str).join(" ");
        return await new Promise((resolve, reject)=>{
            childProcess = (0, _child_process.spawn)(npmCmd, npmRunArgs, {
                cwd: target.cwd,
                stdio: [
                    "inherit",
                    "pipe",
                    "pipe"
                ],
                // This is required for Windows due to https://nodejs.org/en/blog/vulnerability/april-2024-security-releases-2
                ..._os.default.platform() === "win32" && {
                    shell: true
                },
                env: {
                    ...process.stdout.isTTY && {
                        FORCE_COLOR: "1"
                    },
                    ...process.env,
                    ...npmRunNodeOptions && {
                        NODE_OPTIONS: npmRunNodeOptions
                    },
                    LAGE_PACKAGE_NAME: target.packageName,
                    LAGE_TASK: target.task,
                    LAGE_WEIGHT: String(weight)
                }
            });
            let exitHandled = false;
            const handleChildProcessExit = (code)=>{
                childProcess?.off("exit", handleChildProcessExit);
                childProcess?.off("error", handleChildProcessExit);
                if (exitHandled) {
                    return;
                }
                exitHandled = true;
                childProcess?.stdout?.destroy();
                childProcess?.stderr?.destroy();
                childProcess?.stdin?.destroy();
                if (code === 0) {
                    return resolve({
                        exitCode: code
                    });
                }
                reject({
                    exitCode: code,
                    error: new Error(`NPM Script Runner: ${npmCmd} ${npmRunArgs.join(" ")} exited with code ${code}`)
                });
            };
            const { pid } = childProcess;
            process.stdout.write(`Running ${[
                npmCmd,
                ...npmRunArgs
            ].join(" ")}, pid: ${pid}\n`);
            const stdout = childProcess.stdout;
            const stderr = childProcess.stderr;
            stdout.pipe(process.stdout);
            stderr.pipe(process.stderr);
            childProcess.on("exit", handleChildProcessExit);
            childProcess.on("error", ()=>handleChildProcessExit(1));
        });
    }
    constructor(options){
        _define_property(this, "options", void 0);
        this.options = options;
    }
}
_define_property(NpmScriptRunner, "gracefulKillTimeout", 2500);
